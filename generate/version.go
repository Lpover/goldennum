package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type versionInfo struct {
	Time string
	SHA1 string
}

const (
	shortSHA1Length = 6
	generatePrefix  = "// Code generated by github.com/forewing/goldennum/generate. (@generated) DO NOT EDIT."

	versionSourceOutput = "config/version.go"
	versionSourceFormat = generatePrefix + `
package config

var (
	BuildTime = "%v"
	BuildSHA1 = "%v"
)
`
	versionTemplateOutput = "templates/version.html"
	versionTemplateFormat = `{{/* %v */}}
{{ define "version.html" }}%v{{ end }}
`
)

// Generate version.go
func generateVersion() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Fprintf(os.Stderr, "version: %v\n", err)
			os.Exit(1)
		}
	}()

	version := getVersionInfo()

	versionFile, err := os.Create(versionSourceOutput)
	if err != nil {
		panic(err)
	}
	fmt.Fprintf(versionFile, versionSourceFormat, version.Time, version.SHA1)

	templateFile, err := os.Create(versionTemplateOutput)
	if err != nil {
		panic(err)
	}
	shortSHA1 := version.SHA1
	if len(shortSHA1) > shortSHA1Length {
		shortSHA1 = shortSHA1[0:shortSHA1Length]
	}
	if len(shortSHA1) > 0 {
		shortSHA1 = "(" + shortSHA1 + ")"
	}
	fmt.Fprintf(templateFile, versionTemplateFormat, generatePrefix, shortSHA1)
}

func getVersionInfo() (info versionInfo) {
	return versionInfo{
		Time: time.Now().String(),
		SHA1: getVersionSHA1(),
	}
}

func getVersionSHA1() (sha1 string) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Fprintf(os.Stderr, "version: %v\n", err)
		}
	}()

	sha1 = ""

	headData, err := ioutil.ReadFile(".git/HEAD")
	if err != nil {
		panic(err)
	}
	headSplit := strings.Split(strings.TrimSpace(string(headData)), " ")

	if len(headSplit) == 1 {
		// detached HEAD state
		return strings.TrimSpace(headSplit[0])
	}

	sha1Data, err := ioutil.ReadFile(filepath.Join(".git", headSplit[len(headSplit)-1]))
	if err != nil {
		panic(err)
	}

	return strings.TrimSpace(string(sha1Data))
}
